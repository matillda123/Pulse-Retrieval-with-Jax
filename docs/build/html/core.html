

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>core package &mdash; PulseRetrievalwithJAX 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=cb975c41"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="core.gradients package" href="core.gradients.html" />
    <link rel="prev" title="real_fields package" href="real_fields.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PulseRetrievalwithJAX
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="frog.html">frog package</a></li>
<li class="toctree-l1"><a class="reference internal" href="chirp_scan.html">chirp_scan package</a></li>
<li class="toctree-l1"><a class="reference internal" href="tdp.html">tdp package</a></li>
<li class="toctree-l1"><a class="reference internal" href="twodsi.html">twodsi package</a></li>
<li class="toctree-l1"><a class="reference internal" href="vampire.html">vampire package</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulate_trace.html">simulate_trace package</a></li>
<li class="toctree-l1"><a class="reference internal" href="real_fields.html">real_fields package</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">core package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html">core.gradients package</a></li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html">core.hessians package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Equations:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html">Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#Z-Gradients">Z-Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#Z-Pseudo-Hessian">Z-Pseudo Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#PIE-Gradient">PIE Gradient</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#PIE---Pseudo-Hessian">PIE - Pseudo Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#Update-nonlinear-Signal">Update nonlinear Signal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#Adaptive-Stepsize">Adaptive Stepsize</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PulseRetrievalwithJAX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">core package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/core.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="core-package">
<h1>core package<a class="headerlink" href="#core-package" title="Link to this heading"></a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="core.gradients.html">core.gradients package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html#module-core.gradients.chirpscan_z_error_gradients">core.gradients.chirpscan_z_error_gradients module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.chirpscan_z_error_gradients.Z_gradient_shg"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.chirpscan_z_error_gradients.Z_gradient_thg"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.chirpscan_z_error_gradients.Z_gradient_pg"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.chirpscan_z_error_gradients.calculate_Z_gradient"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html#module-core.gradients.frog_z_error_gradients">core.gradients.frog_z_error_gradients module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_shg"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_thg"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_pg"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_sd"><code class="docutils literal notranslate"><span class="pre">Z_gradient_sd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_shg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_thg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_pg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_sd_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_sd_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_shg_interferometric"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg_interferometric()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_thg_interferometric"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg_interferometric()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_pg_interferometric"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg_interferometric()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_shg_interferometric_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg_interferometric_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_thg_interferometric_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg_interferometric_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_pg_interferometric_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg_interferometric_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_shg_interferometric_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg_interferometric_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_thg_interferometric_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg_interferometric_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.Z_gradient_pg_interferometric_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg_interferometric_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.calculate_Z_gradient_pulse"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.calculate_Z_gradient_gate"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.frog_z_error_gradients.calculate_Z_gradient"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html#module-core.gradients.tdp_z_error_gradients">core.gradients.tdp_z_error_gradients module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.tdp_z_error_gradients.calculate_Z_gradient"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html#module-core.gradients.twodsi_z_error_gradients">core.gradients.twodsi_z_error_gradients module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_shg_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_thg_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_pg_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_sd_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_sd_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">Z_gradient_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_shg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_shg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_thg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_thg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_pg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_pg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.Z_gradient_sd_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">Z_gradient_sd_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.calculate_Z_gradient_pulse"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.calculate_Z_gradient_gate"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.twodsi_z_error_gradients.calculate_Z_gradient"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html#module-core.gradients.vampire_z_error_gradients">core.gradients.vampire_z_error_gradients module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.gradients.html#core.gradients.vampire_z_error_gradients.calculate_Z_gradient"><code class="docutils literal notranslate"><span class="pre">calculate_Z_gradient()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html#module-core.gradients">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="core.hessians.html">core.hessians package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#module-core.hessians.chirpscan_z_error_pseudo_hessian">core.hessians.chirpscan_z_error_pseudo_hessian module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.chirpscan_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.chirpscan_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.chirpscan_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.chirpscan_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_element"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_element()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.chirpscan_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_one_m"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_one_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.chirpscan_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_all_m"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_all_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.chirpscan_z_error_pseudo_hessian.get_pseudo_newton_direction_Z_error"><code class="docutils literal notranslate"><span class="pre">get_pseudo_newton_direction_Z_error()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#module-core.hessians.frog_z_error_pseudo_hessian">core.hessians.frog_z_error_pseudo_hessian module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_sd"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_sd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_sd_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_sd_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg_interferometric"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg_interferometric()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg_interferometric"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg_interferometric()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg_interferometric"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg_interferometric()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg_interferometric_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg_interferometric_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg_interferometric_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg_interferometric_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg_interferometric_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg_interferometric_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg_interferometric_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg_interferometric_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg_interferometric_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg_interferometric_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg_interferometric_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg_interferometric_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_element_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_element_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_element_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_element_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_one_m"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_one_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_all_m"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_all_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.frog_z_error_pseudo_hessian.get_pseudo_newton_direction_Z_error"><code class="docutils literal notranslate"><span class="pre">get_pseudo_newton_direction_Z_error()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#module-core.hessians.pie_pseudo_hessian">core.hessians.pie_pseudo_hessian module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.pie_pseudo_hessian.PIE_get_pseudo_hessian_element"><code class="docutils literal notranslate"><span class="pre">PIE_get_pseudo_hessian_element()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.pie_pseudo_hessian.PIE_get_pseudo_hessian_one_m"><code class="docutils literal notranslate"><span class="pre">PIE_get_pseudo_hessian_one_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.pie_pseudo_hessian.PIE_get_pseudo_hessian_all_m"><code class="docutils literal notranslate"><span class="pre">PIE_get_pseudo_hessian_all_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.pie_pseudo_hessian.PIE_get_pseudo_newton_direction"><code class="docutils literal notranslate"><span class="pre">PIE_get_pseudo_newton_direction()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#module-core.hessians.tdp_z_error_pseudo_hessian">core.hessians.tdp_z_error_pseudo_hessian module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.tdp_z_error_pseudo_hessian.get_pseudo_newton_direction_Z_error"><code class="docutils literal notranslate"><span class="pre">get_pseudo_newton_direction_Z_error()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#module-core.hessians.twodsi_z_error_pseudo_hessian">core.hessians.twodsi_z_error_pseudo_hessian module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_sd_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_sd_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_cross_correlation_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_cross_correlation_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_shg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_shg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_thg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_thg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_pg_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_pg_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_subelement_sd_cross_correlation_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_subelement_sd_cross_correlation_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_element_pulse"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_element_pulse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_element_gate"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_element_gate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_one_m"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_one_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.calc_Z_error_pseudo_hessian_all_m"><code class="docutils literal notranslate"><span class="pre">calc_Z_error_pseudo_hessian_all_m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.twodsi_z_error_pseudo_hessian.get_pseudo_newton_direction_Z_error"><code class="docutils literal notranslate"><span class="pre">get_pseudo_newton_direction_Z_error()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#module-core.hessians.vampire_z_error_pseudo_hessian">core.hessians.vampire_z_error_pseudo_hessian module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core.hessians.html#core.hessians.vampire_z_error_pseudo_hessian.get_pseudo_newton_direction_Z_error"><code class="docutils literal notranslate"><span class="pre">get_pseudo_newton_direction_Z_error()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html#module-core.hessians">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-core.base_classes_algorithms">
<span id="core-base-classes-algorithms-module"></span><h2>core.base_classes_algorithms module<a class="headerlink" href="#module-core.base_classes_algorithms" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_algorithms.</span></span><span class="sig-name descname"><span class="pre">AlgorithmsBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Base-Class for all solvers.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.jit">
<span class="sig-name descname"><span class="pre">jit</span></span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.jit" title="Link to this definition"></a></dt>
<dd><p>enables/disables jax.jit</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.spectrum_is_being_used">
<span class="sig-name descname"><span class="pre">spectrum_is_being_used</span></span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.spectrum_is_being_used" title="Link to this definition"></a></dt>
<dd><p>what the name says</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.fft">
<span class="sig-name descname"><span class="pre">fft</span></span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.fft" title="Link to this definition"></a></dt>
<dd><p>performs an fft, performs an fft of a signal. (Needs to expect signal, sk, rn, axis)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.ifft">
<span class="sig-name descname"><span class="pre">ifft</span></span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.ifft" title="Link to this definition"></a></dt>
<dd><p>performs an ifft, performs an ifft of a signal. (Needs to expect signal, sk, rn, axis)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.run" title="Link to this definition"></a></dt>
<dd><p>This function is invoked by most solvers to perform the iterative reconstruction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.do_step_and_apply_spectrum">
<span class="sig-name descname"><span class="pre">do_step_and_apply_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_step</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.do_step_and_apply_spectrum" title="Link to this definition"></a></dt>
<dd><p>If a spectrum is provided this wraps around the step-method of all solvers and projects the current guess onto the measured spectrum.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.use_measured_spectrum">
<span class="sig-name descname"><span class="pre">use_measured_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pulse'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.use_measured_spectrum" title="Link to this definition"></a></dt>
<dd><p>Needs to be called if a pulse spectrum is meant to be used in the reconstruction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequency</strong> – jnp.array, the frequency axis of spectrum</p></li>
<li><p><strong>spectrum</strong> – jnp.array, the spectrum</p></li>
<li><p><strong>pulse_or_gate</strong> (<em>str</em>) – whether the spectrum is from the pulse or the gate-pulse.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the class instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.apply_spectrum">
<span class="sig-name descname"><span class="pre">apply_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.apply_spectrum" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.apply_spectrum_time_domain">
<span class="sig-name descname"><span class="pre">apply_spectrum_time_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.apply_spectrum_time_domain" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.AlgorithmsBASE.apply_spectrum_frequency_domain">
<span class="sig-name descname"><span class="pre">apply_spectrum_frequency_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.AlgorithmsBASE.apply_spectrum_frequency_domain" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_algorithms.</span></span><span class="sig-name descname"><span class="pre">ClassicAlgorithmsBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.AlgorithmsBASE" title="core.base_classes_algorithms.AlgorithmsBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmsBASE</span></code></a></p>
<p>The Base-Class for all classical solvers (e.g. Generalized Projection, …). Inherits from AlgorithmsBASE.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.local_gamma">
<span class="sig-name descname"><span class="pre">local_gamma</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.local_gamma" title="Link to this definition"></a></dt>
<dd><p>step size for local iterations</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.global_gamma">
<span class="sig-name descname"><span class="pre">global_gamma</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.global_gamma" title="Link to this definition"></a></dt>
<dd><p>step size for global iterations</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.linesearch">
<span class="sig-name descname"><span class="pre">linesearch</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.linesearch" title="Link to this definition"></a></dt>
<dd><p>enables/disables a linesearch. Can be False, backtracking or zoom.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.max_steps_linesearch">
<span class="sig-name descname"><span class="pre">max_steps_linesearch</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.max_steps_linesearch" title="Link to this definition"></a></dt>
<dd><p>maximum number of linesearch steos</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.c1">
<span class="sig-name descname"><span class="pre">c1</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.c1" title="Link to this definition"></a></dt>
<dd><p>constant for the Armijo-condition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.c2">
<span class="sig-name descname"><span class="pre">c2</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.c2" title="Link to this definition"></a></dt>
<dd><p>constant for the strong Wolfe-condition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.delta_gamma">
<span class="sig-name descname"><span class="pre">delta_gamma</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.delta_gamma" title="Link to this definition"></a></dt>
<dd><p>a factor which by which gamma is increased each iteration</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.local_newton">
<span class="sig-name descname"><span class="pre">local_newton</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.local_newton" title="Link to this definition"></a></dt>
<dd><p>enables/disables the use of a hessian in local iterations. Can be False, lbfgs or diagonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.global_newton">
<span class="sig-name descname"><span class="pre">global_newton</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.global_newton" title="Link to this definition"></a></dt>
<dd><p>enables/disables the use of a hessian in global iterations. Can be False, lbfgs, diagonal or full.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.lambda_lm">
<span class="sig-name descname"><span class="pre">lambda_lm</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.lambda_lm" title="Link to this definition"></a></dt>
<dd><p>a Levenberg-Marquardt style damping coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.lbfgs_memory">
<span class="sig-name descname"><span class="pre">lbfgs_memory</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.lbfgs_memory" title="Link to this definition"></a></dt>
<dd><p>the number of past iterations to use in LBFGS</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.linalg_solver">
<span class="sig-name descname"><span class="pre">linalg_solver</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.linalg_solver" title="Link to this definition"></a></dt>
<dd><p>chooses a library/method for inverting the hessian. Can be scipy, lineax or a specific lineax solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str, lineax-solver</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.conjugate_gradients">
<span class="sig-name descname"><span class="pre">conjugate_gradients</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.conjugate_gradients" title="Link to this definition"></a></dt>
<dd><p>enables/diables the use of the Nonlinear Conjugate Gradients method. Can be False, Fletcher-Reeves,
Hestenes-Stiefel, Dai-Yuan, Polak-Ribiere or average.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.r_local_method">
<span class="sig-name descname"><span class="pre">r_local_method</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.r_local_method" title="Link to this definition"></a></dt>
<dd><p>chooses the method on the calculation of S_prime in local iterations. Can be projection or iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.r_global_method">
<span class="sig-name descname"><span class="pre">r_global_method</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.r_global_method" title="Link to this definition"></a></dt>
<dd><p>chooses the method on the calculation of S_prime in global iterations. Can be projection or iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.r_gradient">
<span class="sig-name descname"><span class="pre">r_gradient</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.r_gradient" title="Link to this definition"></a></dt>
<dd><p>if r_method=iteration, chooses the type of residual to optimize. Can be amplitude or intensity.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.r_newton">
<span class="sig-name descname"><span class="pre">r_newton</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.r_newton" title="Link to this definition"></a></dt>
<dd><p>enables/diables the use of the diagonal hessian if r_method=iteration</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.r_weights">
<span class="sig-name descname"><span class="pre">r_weights</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.r_weights" title="Link to this definition"></a></dt>
<dd><p>allows the weigthing of residuals</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.r_no_iterations">
<span class="sig-name descname"><span class="pre">r_no_iterations</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.r_no_iterations" title="Link to this definition"></a></dt>
<dd><p>the number of iterations if r_method=iteration</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.r_step_scaling">
<span class="sig-name descname"><span class="pre">r_step_scaling</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.r_step_scaling" title="Link to this definition"></a></dt>
<dd><p>the type of adpative step-size scaling to use if r_method=iteration</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.xi">
<span class="sig-name descname"><span class="pre">xi</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.xi" title="Link to this definition"></a></dt>
<dd><p>a damping coefficient for adaptive step-sizes, avoids division by zero</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.local_adaptive_scaling">
<span class="sig-name descname"><span class="pre">local_adaptive_scaling</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.local_adaptive_scaling" title="Link to this definition"></a></dt>
<dd><p>enables/disables adaptive step sized in local iterations. Can be one of False, pade_10 (linear), pade_20 (nonlinear),
pade_11, pade_01 or pade_02</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.global_adaptive_scaling">
<span class="sig-name descname"><span class="pre">global_adaptive_scaling</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.global_adaptive_scaling" title="Link to this definition"></a></dt>
<dd><p>enables/disables adaptive step sized in global iterations. Can be one of False, pade_10 (linear), pade_20 (nonlinear),
pade_11, pade_01 or pade_02</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.momentum_is_being_used">
<span class="sig-name descname"><span class="pre">momentum_is_being_used</span></span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.momentum_is_being_used" title="Link to this definition"></a></dt>
<dd><p>what the name says</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.shuffle_data_along_m">
<span class="sig-name descname"><span class="pre">shuffle_data_along_m</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.shuffle_data_along_m" title="Link to this definition"></a></dt>
<dd><p>Some solvers randomize local iterations. This is done through this method.
It returns shuffled but consistent(!) data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.do_step_and_apply_momentum">
<span class="sig-name descname"><span class="pre">do_step_and_apply_momentum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_step</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.do_step_and_apply_momentum" title="Link to this definition"></a></dt>
<dd><p>If momentum is being used this wraps around the step-method of all solvers and updates the current guess accordingly.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.momentum">
<span class="sig-name descname"><span class="pre">momentum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.momentum" title="Link to this definition"></a></dt>
<dd><p>Needs to be called if momentum is meant to be used in the reconstruction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population_size</strong> – int, is needed for some initialization</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – parameter that controls the momentum strength</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the class instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.ClassicAlgorithmsBASE.apply_momentum">
<span class="sig-name descname"><span class="pre">apply_momentum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE.apply_momentum" title="Link to this definition"></a></dt>
<dd><p>Applies momentum to a signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> – jnp.array,</p></li>
<li><p><strong>momentum</strong> – Pytree, contains the velocity map and its update</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – the strength of the momentum</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[jnp.array, Pytree], the updated signal and momentum state</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_algorithms.</span></span><span class="sig-name descname"><span class="pre">GeneralOptimizationBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.AlgorithmsBASE" title="core.base_classes_algorithms.AlgorithmsBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmsBASE</span></code></a></p>
<p>The Base-Class for all general solvers. Inherits from AlgorithmsBASE.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.fd_grad">
<span class="sig-name descname"><span class="pre">fd_grad</span></span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.fd_grad" title="Link to this definition"></a></dt>
<dd><p>the loss function can be calcualted with the residuals of the finite-differences of the trace</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.amplitude_or_intensity">
<span class="sig-name descname"><span class="pre">amplitude_or_intensity</span></span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.amplitude_or_intensity" title="Link to this definition"></a></dt>
<dd><p>the loss function can be calculated with the residuals of fields to arbitrary powers</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str, int, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.error_metric">
<span class="sig-name descname"><span class="pre">error_metric</span></span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.error_metric" title="Link to this definition"></a></dt>
<dd><p>an arbitrary loss-function, needs to expect (trace, measured_trace) as input</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.create_initial_population">
<span class="sig-name descname"><span class="pre">create_initial_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'polynomial'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_funcs_amp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_funcs_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.create_initial_population" title="Link to this definition"></a></dt>
<dd><p>Creates an initial guess either explicit or parametrized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population_size</strong> – int, the number of individuals</p></li>
<li><p><strong>amp_type</strong> (<em>str</em>) – the representation of the spectral amplitude, can be one of gaussian, lorentzian, bsplines or discrete</p></li>
<li><p><strong>phase_type</strong> (<em>str</em>) – the representation of the spectral phase, can be one of polynomial, sinusoidal, sigmoidal, bsplines or discrete</p></li>
<li><p><strong>no_funcs_amp</strong> – int, the number of basis functions for the spectral amplitude (if parametrized)</p></li>
<li><p><strong>no_funcs_phase</strong> – int, the number of basis functions for the spectral phase (if parametrized)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, the initial guess population</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.split_population_in_amp_and_phase">
<span class="sig-name descname"><span class="pre">split_population_in_amp_and_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.split_population_in_amp_and_phase" title="Link to this definition"></a></dt>
<dd><p>Splits a population into an amplitude and phase population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.merge_population_from_amp_and_phase">
<span class="sig-name descname"><span class="pre">merge_population_from_amp_and_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population_phase</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.merge_population_from_amp_and_phase" title="Link to this definition"></a></dt>
<dd><p>Undoes split_population_in_amp_and_phase()</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.polynomial_term">
<span class="sig-name descname"><span class="pre">polynomial_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.polynomial_term" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.polynomial_phase">
<span class="sig-name descname"><span class="pre">polynomial_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.polynomial_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.sinusoidal_term">
<span class="sig-name descname"><span class="pre">sinusoidal_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.sinusoidal_term" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.sinusoidal_phase">
<span class="sig-name descname"><span class="pre">sinusoidal_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.sinusoidal_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.discrete_phase">
<span class="sig-name descname"><span class="pre">discrete_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.discrete_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.tanh_term">
<span class="sig-name descname"><span class="pre">tanh_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.tanh_term" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.tanh_phase">
<span class="sig-name descname"><span class="pre">tanh_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.tanh_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.bspline_phase">
<span class="sig-name descname"><span class="pre">bspline_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.bspline_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.gaussian_term">
<span class="sig-name descname"><span class="pre">gaussian_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.gaussian_term" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.gaussian_amplitude">
<span class="sig-name descname"><span class="pre">gaussian_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.gaussian_amplitude" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.lorentzian_term">
<span class="sig-name descname"><span class="pre">lorentzian_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.lorentzian_term" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.lorentzian_amplitude">
<span class="sig-name descname"><span class="pre">lorentzian_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.lorentzian_amplitude" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.discrete_amplitude">
<span class="sig-name descname"><span class="pre">discrete_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.discrete_amplitude" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.bspline_amplitude">
<span class="sig-name descname"><span class="pre">bspline_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.bspline_amplitude" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.get_phase">
<span class="sig-name descname"><span class="pre">get_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.get_phase" title="Link to this definition"></a></dt>
<dd><p>Evaluates the spectral phase onto the frequency axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.get_amplitude">
<span class="sig-name descname"><span class="pre">get_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.get_amplitude" title="Link to this definition"></a></dt>
<dd><p>Evaluates the spectral amplitude onto the frequency axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.make_pulse_f_from_individual">
<span class="sig-name descname"><span class="pre">make_pulse_f_from_individual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pulse'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.make_pulse_f_from_individual" title="Link to this definition"></a></dt>
<dd><p>Evaluates a parametrized individual onto the frequency axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.get_pulses_f_from_population">
<span class="sig-name descname"><span class="pre">get_pulses_f_from_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.get_pulses_f_from_population" title="Link to this definition"></a></dt>
<dd><p>Evaluates a parametrized population onto the frequency axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.make_pulse_t_from_individual">
<span class="sig-name descname"><span class="pre">make_pulse_t_from_individual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pulse'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.make_pulse_t_from_individual" title="Link to this definition"></a></dt>
<dd><p>Evaluates a parametrized individual onto the time axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.get_pulses_t_from_population">
<span class="sig-name descname"><span class="pre">get_pulses_t_from_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.get_pulses_t_from_population" title="Link to this definition"></a></dt>
<dd><p>Evaluates a parametrized population onto the time axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.construct_trace">
<span class="sig-name descname"><span class="pre">construct_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.construct_trace" title="Link to this definition"></a></dt>
<dd><p>Generates a trace for a given individual. Calls the method specific function for calculating the nonlinear signal fields.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.trace_error">
<span class="sig-name descname"><span class="pre">trace_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.trace_error" title="Link to this definition"></a></dt>
<dd><p>The mean least squares error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.calculate_error_individual">
<span class="sig-name descname"><span class="pre">calculate_error_individual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.calculate_error_individual" title="Link to this definition"></a></dt>
<dd><p>Calculates the error of an individual based on its trace.
Allows modification of the error-function via error_metric() and loss_function_modification().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.calculate_error_population">
<span class="sig-name descname"><span class="pre">calculate_error_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.calculate_error_population" title="Link to this definition"></a></dt>
<dd><p>Calls jax.vmap over calculate_error_individual() for an entire population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.initialize_general_optimizer">
<span class="sig-name descname"><span class="pre">initialize_general_optimizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.initialize_general_optimizer" title="Link to this definition"></a></dt>
<dd><p>A common initialization step for all general solvers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.get_idx_best_individual">
<span class="sig-name descname"><span class="pre">get_idx_best_individual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.get_idx_best_individual" title="Link to this definition"></a></dt>
<dd><p>Calculates the error for a population. Returns the index of the lowest individual.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_algorithms.GeneralOptimizationBASE.post_process_get_pulse_and_gate">
<span class="sig-name descname"><span class="pre">post_process_get_pulse_and_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_algorithms.GeneralOptimizationBASE.post_process_get_pulse_and_gate" title="Link to this definition"></a></dt>
<dd><p>Post-processing to evaluate parametrized individuals.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-core.base_classes_methods">
<span id="core-base-classes-methods-module"></span><h2>core.base_classes_methods module<a class="headerlink" href="#module-core.base_classes_methods" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_methods.</span></span><span class="sig-name descname"><span class="pre">RetrievePulses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Base-Class for all reconstruction methods. Defines general initialization, preprocessing and postprocessing.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.nonlinear_method">
<span class="sig-name descname"><span class="pre">nonlinear_method</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.nonlinear_method" title="Link to this definition"></a></dt>
<dd><p>SHG, THG, PG or SD</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.f0">
<span class="sig-name descname"><span class="pre">f0</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.f0" title="Link to this definition"></a></dt>
<dd><p>rarely some solvers need the central frequency to be zero. This saves the original central frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.doubleblind">
<span class="sig-name descname"><span class="pre">doubleblind</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.doubleblind" title="Link to this definition"></a></dt>
<dd><p>whether the reconstruction is supposed to yield the gate in addition to the pulse.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.spectrum_is_being_used">
<span class="sig-name descname"><span class="pre">spectrum_is_being_used</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.spectrum_is_being_used" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.momentum_is_being_used">
<span class="sig-name descname"><span class="pre">momentum_is_being_used</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.momentum_is_being_used" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.measurement_info">
<span class="sig-name descname"><span class="pre">measurement_info</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.measurement_info" title="Link to this definition"></a></dt>
<dd><p>a container of variable (but static) structure. Holds measurement data and parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pytree</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.descent_info">
<span class="sig-name descname"><span class="pre">descent_info</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.descent_info" title="Link to this definition"></a></dt>
<dd><p>a container of variable (but static) structure. Holds parameters of the reconstruction algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pytree</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.descent_state">
<span class="sig-name descname"><span class="pre">descent_state</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.descent_state" title="Link to this definition"></a></dt>
<dd><p>a container of variable (but static) structure. Contains the current state of the solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pytree</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.prng_seed">
<span class="sig-name descname"><span class="pre">prng_seed</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.prng_seed" title="Link to this definition"></a></dt>
<dd><p>seed for the key</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.key">
<span class="sig-name descname"><span class="pre">key</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.key" title="Link to this definition"></a></dt>
<dd><p>a jax.random.PRNGKey</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.factor">
<span class="sig-name descname"><span class="pre">factor</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.factor" title="Link to this definition"></a></dt>
<dd><p>for SHG/THG the a correction factor of 2/3 needs to applied occasionally.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.x_arr">
<span class="sig-name descname"><span class="pre">x_arr</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.x_arr" title="Link to this definition"></a></dt>
<dd><p>an alias for the shifts/delays, internally indexed via m</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.time">
<span class="sig-name descname"><span class="pre">time</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.time" title="Link to this definition"></a></dt>
<dd><p>the time axis, internally indexed via k</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.frequency">
<span class="sig-name descname"><span class="pre">frequency</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.frequency" title="Link to this definition"></a></dt>
<dd><p>the frequency axis, internally indexed via n</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.measured_trace">
<span class="sig-name descname"><span class="pre">measured_trace</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.measured_trace" title="Link to this definition"></a></dt>
<dd><p>2D-array with the measured data. axis=0 corresponds to shift/delay (index m), axis=1 correpsonds to the frequencies (index n)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.update_PRNG_key">
<span class="sig-name descname"><span class="pre">update_PRNG_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.update_PRNG_key" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.get_data">
<span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.get_data" title="Link to this definition"></a></dt>
<dd><p>Prepare/Convert data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.get_spectral_amplitude">
<span class="sig-name descname"><span class="pre">get_spectral_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measured_frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.get_spectral_amplitude" title="Link to this definition"></a></dt>
<dd><p>Used to provide a measured pulse spectrum. A spectrum for the gate pulse can also be provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.get_gate_pulse">
<span class="sig-name descname"><span class="pre">get_gate_pulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gate_f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.get_gate_pulse" title="Link to this definition"></a></dt>
<dd><p>For crosscorrelation=True the actual gate pulse has to be provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.create_initial_population">
<span class="sig-name descname"><span class="pre">create_initial_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.create_initial_population" title="Link to this definition"></a></dt>
<dd><p>Creates an initial population.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population_size</strong> – int,</p></li>
<li><p><strong>guess_type</strong> – str, can be one of random, random_phase, constant or constant_phase</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[jnp.array, jnp.array or None], initial populations for the pulse and possibly the gate-pulse</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.get_individual_from_idx">
<span class="sig-name descname"><span class="pre">get_individual_from_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.get_individual_from_idx" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.plot_results">
<span class="sig-name descname"><span class="pre">plot_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">final_result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_pulse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doubleblind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.plot_results" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.get_idx_best_individual">
<span class="sig-name descname"><span class="pre">get_idx_best_individual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.get_idx_best_individual" title="Link to this definition"></a></dt>
<dd><p>Calculates trace error for whole population. Returns the idx of the individual with the smallest error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.post_process_center_pulse_and_gate">
<span class="sig-name descname"><span class="pre">post_process_center_pulse_and_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gate_t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.post_process_center_pulse_and_gate" title="Link to this definition"></a></dt>
<dd><p>This essentially removes the linear phase. But only approximately since no fits are done.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.post_process_create_trace">
<span class="sig-name descname"><span class="pre">post_process_create_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.post_process_create_trace" title="Link to this definition"></a></dt>
<dd><p>Post processing to get the final trace</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.post_process">
<span class="sig-name descname"><span class="pre">post_process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_arr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.post_process" title="Link to this definition"></a></dt>
<dd><p>Creates the final_result object from the final descent_state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses.get_final_result_population">
<span class="sig-name descname"><span class="pre">get_final_result_population</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses.get_final_result_population" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_methods.</span></span><span class="sig-name descname"><span class="pre">RetrievePulsesFROG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_correlation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interferometric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_methods.RetrievePulses" title="core.base_classes_methods.RetrievePulses"><code class="xref py py-class docutils literal notranslate"><span class="pre">RetrievePulses</span></code></a></p>
<p>The reconstruction class for FROG. Inherits from RetrievePulses.</p>
<p>[1] R. Trebino, “Frequency-Resolved Optical Gating: The Measurement of Ultrashort Laser Pulses”, 10.1007/978-1-4615-1181-6 (2000)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.tau_arr">
<span class="sig-name descname"><span class="pre">tau_arr</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.tau_arr" title="Link to this definition"></a></dt>
<dd><p>the delays</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.gate">
<span class="sig-name descname"><span class="pre">gate</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.gate" title="Link to this definition"></a></dt>
<dd><p>the gate-pulse (if its known).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.transform_arr">
<span class="sig-name descname"><span class="pre">transform_arr</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.transform_arr" title="Link to this definition"></a></dt>
<dd><p>an alias for tau_arr</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.idx_arr">
<span class="sig-name descname"><span class="pre">idx_arr</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.idx_arr" title="Link to this definition"></a></dt>
<dd><p>an array with indices for tau_arr</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.dt">
<span class="sig-name descname"><span class="pre">dt</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.dt" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.df">
<span class="sig-name descname"><span class="pre">df</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.df" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.sk">
<span class="sig-name descname"><span class="pre">sk</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.sk" title="Link to this definition"></a></dt>
<dd><p>correction values for FFT-&gt;DFT</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.rn">
<span class="sig-name descname"><span class="pre">rn</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.rn" title="Link to this definition"></a></dt>
<dd><p>correction values for FFT-&gt;DFT</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.cross_correlation">
<span class="sig-name descname"><span class="pre">cross_correlation</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.cross_correlation" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.interferometric">
<span class="sig-name descname"><span class="pre">interferometric</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.interferometric" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.create_initial_population">
<span class="sig-name descname"><span class="pre">create_initial_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.create_initial_population" title="Link to this definition"></a></dt>
<dd><p>Creates an initial guess. The guess is in the time domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population_size</strong> – int, the number of guesses</p></li>
<li><p><strong>guess_type</strong> – str, the guess type. Can be one of random, random_phase, constant or constant_phase.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.create_initial_population_doublepulse">
<span class="sig-name descname"><span class="pre">create_initial_population_doublepulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_size</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.create_initial_population_doublepulse" title="Link to this definition"></a></dt>
<dd><p>Calls initial_guess_doublepulse.make_population_doublepulse to create an initial guess.
The guess is in the time domain. Assumes an autocorrelation FROG.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population_size</strong> – int,</p></li>
<li><p><strong>**kwargs</strong> – passed to make_population_doublepulse()</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.shift_signal_in_time">
<span class="sig-name descname"><span class="pre">shift_signal_in_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.shift_signal_in_time" title="Link to this definition"></a></dt>
<dd><p>The Fourier-Shift theorem.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.calculate_shifted_signal">
<span class="sig-name descname"><span class="pre">calculate_shifted_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(None,</span> <span class="pre">0,</span> <span class="pre">None,</span> <span class="pre">None,</span> <span class="pre">None)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.calculate_shifted_signal" title="Link to this definition"></a></dt>
<dd><p>The Fourier-Shift theorem applied to a list of signals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.calculate_signal_t">
<span class="sig-name descname"><span class="pre">calculate_signal_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.calculate_signal_t" title="Link to this definition"></a></dt>
<dd><p>Calculates the signal field of a FROG in the time domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>individual</strong> – Pytree, a population containing only one member. (jax.vmap over whole population)</p></li>
<li><p><strong>tau_arr</strong> (<em>jnp.array</em>) – the delays</p></li>
<li><p><strong>measurement_info</strong> – Pytree, contains the measurement parameters (e.g. nonlinear method, interferometric, … )</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, contains the signal field in the time domain as well as the fields used to calculate it.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.generate_signal_t">
<span class="sig-name descname"><span class="pre">generate_signal_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.generate_signal_t" title="Link to this definition"></a></dt>
<dd><p>Applies calculate_signal_t to a whole population via jax.vmap</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesFROG.post_process_get_pulse_and_gate">
<span class="sig-name descname"><span class="pre">post_process_get_pulse_and_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesFROG.post_process_get_pulse_and_gate" title="Link to this definition"></a></dt>
<dd><p>FROG specific post processing to get the final pulse/gate</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesTDP">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_methods.</span></span><span class="sig-name descname"><span class="pre">RetrievePulsesTDP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesTDP" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_methods.RetrievePulsesFROG" title="core.base_classes_methods.RetrievePulsesFROG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RetrievePulsesFROG</span></code></a></p>
<p>The reconstruction class for Time-Domain-Ptychography.</p>
<p>[1] D. Spangenberg et al., Phys. Rev. A 91, 021803(R), 10.1103/PhysRevA.91.021803 (2015)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesTDP.spectral_filter">
<span class="sig-name descname"><span class="pre">spectral_filter</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesTDP.spectral_filter" title="Link to this definition"></a></dt>
<dd><p>the spectral filter in the gate arm.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesTDP.apply_spectral_filter">
<span class="sig-name descname"><span class="pre">apply_spectral_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesTDP.apply_spectral_filter" title="Link to this definition"></a></dt>
<dd><p>Apply a spectral filter to a signal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesTDP.calculate_signal_t">
<span class="sig-name descname"><span class="pre">calculate_signal_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesTDP.calculate_signal_t" title="Link to this definition"></a></dt>
<dd><p>Calculates the signal field of TDP in the time domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>individual</strong> – Pytree, a population containing only one member. (jax.vmap over whole population)</p></li>
<li><p><strong>tau_arr</strong> (<em>jnp.array</em>) – the delays</p></li>
<li><p><strong>measurement_info</strong> – Pytree, contains the measurement parameters (e.g. nonlinear method, interferometric, … )</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, contains the signal field in the time domain as well as the fields used to calculate it.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_methods.</span></span><span class="sig-name descname"><span class="pre">RetrievePulsesCHIRPSCAN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chirp_parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_methods.RetrievePulses" title="core.base_classes_methods.RetrievePulses"><code class="xref py py-class docutils literal notranslate"><span class="pre">RetrievePulses</span></code></a></p>
<p>The reconstruction class for Chirp-Scan methods.</p>
<p>[1] V. V. Lozovoy et al., Optics Letters 29, 775-777 (2004)
[2] M. Miranda et al., Opt. Express 20, 18732-18743 (2012)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.z_arr">
<span class="sig-name descname"><span class="pre">z_arr</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.z_arr" title="Link to this definition"></a></dt>
<dd><p>the shifts</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.dt">
<span class="sig-name descname"><span class="pre">dt</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.dt" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.df">
<span class="sig-name descname"><span class="pre">df</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.df" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.sk">
<span class="sig-name descname"><span class="pre">sk</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.sk" title="Link to this definition"></a></dt>
<dd><p>correction values for FFT-&gt;DFT</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.rn">
<span class="sig-name descname"><span class="pre">rn</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.rn" title="Link to this definition"></a></dt>
<dd><p>correction values for FFT-&gt;DFT</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.phase_matrix">
<span class="sig-name descname"><span class="pre">phase_matrix</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.phase_matrix" title="Link to this definition"></a></dt>
<dd><p>a 2D-array with the phase values applied to pulse</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.parameters">
<span class="sig-name descname"><span class="pre">parameters</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.parameters" title="Link to this definition"></a></dt>
<dd><p>tuple, parameters for the chirp function</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.transform_arr">
<span class="sig-name descname"><span class="pre">transform_arr</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.transform_arr" title="Link to this definition"></a></dt>
<dd><p>an alias for phase_matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.idx_arr">
<span class="sig-name descname"><span class="pre">idx_arr</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.idx_arr" title="Link to this definition"></a></dt>
<dd><p>indices for z_arr</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.get_phase_matrix">
<span class="sig-name descname"><span class="pre">get_phase_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.get_phase_matrix" title="Link to this definition"></a></dt>
<dd><p>Calls phase_matrix_func in order to calculate the phase matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.create_initial_population">
<span class="sig-name descname"><span class="pre">create_initial_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.create_initial_population" title="Link to this definition"></a></dt>
<dd><p>Creates an initial guess. The guess is in the frequency domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population_size</strong> – int, the number of guesses</p></li>
<li><p><strong>guess_type</strong> – str, the guess type. Can be one of random, random_phase, constant or constant_phase.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.get_dispersed_pulse_t">
<span class="sig-name descname"><span class="pre">get_dispersed_pulse_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.get_dispersed_pulse_t" title="Link to this definition"></a></dt>
<dd><p>Applies phase-matrix to a signal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.calculate_signal_t">
<span class="sig-name descname"><span class="pre">calculate_signal_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.calculate_signal_t" title="Link to this definition"></a></dt>
<dd><p>Calculates the signal field of a Chirp-Scan in the time domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>individual</strong> – Pytree, a population containing only one member. (jax.vmap over whole population)</p></li>
<li><p><strong>phase_matrix</strong> (<em>jnp.array</em>) – the applied phases</p></li>
<li><p><strong>measurement_info</strong> – Pytree, contains the measurement parameters (e.g. nonlinear method, … )</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, contains the signal field in the time domain as well as the fields used to calculate it.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.generate_signal_t">
<span class="sig-name descname"><span class="pre">generate_signal_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.generate_signal_t" title="Link to this definition"></a></dt>
<dd><p>Applies calculate_signal_t to a whole population via jax.vmap</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesCHIRPSCAN.post_process_get_pulse_and_gate">
<span class="sig-name descname"><span class="pre">post_process_get_pulse_and_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesCHIRPSCAN.post_process_get_pulse_and_gate" title="Link to this definition"></a></dt>
<dd><p>Chirp-Scan specific post processing to get the final pulse/gate</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_methods.</span></span><span class="sig-name descname"><span class="pre">RetrievePulses2DSI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_correlation=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_filter1=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_filter2=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_pulse_anc1=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">material_thickness=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refractive_index=&lt;refractiveindex.refractiveindex.RefractiveIndexMaterial</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_methods.RetrievePulsesFROG" title="core.base_classes_methods.RetrievePulsesFROG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RetrievePulsesFROG</span></code></a></p>
<p>The reconstruction class for 2DSI.</p>
<p>[1] J. R. Birge et al., Opt. Lett. 31, 2063-2065 (2006)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.spectral_filter1">
<span class="sig-name descname"><span class="pre">spectral_filter1</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.spectral_filter1" title="Link to this definition"></a></dt>
<dd><p>1st filter in interferometer</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.spectral_filter2">
<span class="sig-name descname"><span class="pre">spectral_filter2</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.spectral_filter2" title="Link to this definition"></a></dt>
<dd><p>2nd filter in interferometer</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.tau_pulse_anc1">
<span class="sig-name descname"><span class="pre">tau_pulse_anc1</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.tau_pulse_anc1" title="Link to this definition"></a></dt>
<dd><p>delay between 1st interferometer arm and exterior pulse</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.anc_frequency1">
<span class="sig-name descname"><span class="pre">anc_frequency1</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.anc_frequency1" title="Link to this definition"></a></dt>
<dd><p>central frequency of pulse in 1st arm (calculated from max of spectral_filter1)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.anc_frequency2">
<span class="sig-name descname"><span class="pre">anc_frequency2</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.anc_frequency2" title="Link to this definition"></a></dt>
<dd><p>central frequency of pulse in 2nd arm (calculated from max of spectral_filter2)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.c0">
<span class="sig-name descname"><span class="pre">c0</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.c0" title="Link to this definition"></a></dt>
<dd><p>the speed of light</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.refractive_index">
<span class="sig-name descname"><span class="pre">refractive_index</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.refractive_index" title="Link to this definition"></a></dt>
<dd><p>returns the refractive index for a material given a wavelength in um</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>refractiveindex.RefractiveIndexMaterial, Callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.phase_matrix">
<span class="sig-name descname"><span class="pre">phase_matrix</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.phase_matrix" title="Link to this definition"></a></dt>
<dd><p>a 2D-array with phase values that could potentially have been applied to a pulse</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.get_phase_matrix">
<span class="sig-name descname"><span class="pre">get_phase_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refractive_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">material_thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.get_phase_matrix" title="Link to this definition"></a></dt>
<dd><p>Calculates the phase matrix that is applied of a pulse passes through a material.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.apply_phase">
<span class="sig-name descname"><span class="pre">apply_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.apply_phase" title="Link to this definition"></a></dt>
<dd><p>For a 2DSI reconstruction one may need to consider effects of material dispersion in the interferometer.
This applies a dispersion based on phase_matrix in order to achieve this.
In addition the dispersion may contain a group delay. This delay is estimated, corrected and returned as well.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.apply_spectral_filter">
<span class="sig-name descname"><span class="pre">apply_spectral_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.apply_spectral_filter" title="Link to this definition"></a></dt>
<dd><p>Apply a spectral filter to a signal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulses2DSI.calculate_signal_t">
<span class="sig-name descname"><span class="pre">calculate_signal_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulses2DSI.calculate_signal_t" title="Link to this definition"></a></dt>
<dd><p>Calculates the signal field of 2DSI in the time domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>individual</strong> – Pytree, a population containing only one member. (jax.vmap over whole population)</p></li>
<li><p><strong>tau_arr</strong> (<em>jnp.array</em>) – the delays</p></li>
<li><p><strong>measurement_info</strong> – Pytree, contains the measurement parameters (e.g. nonlinear method, … )</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, contains the signal field in the time domain as well as the fields used to calculate it.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classes_methods.</span></span><span class="sig-name descname"><span class="pre">RetrievePulsesVAMPIRE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_correlation=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_interferometer=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">material_thickness=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refractive_index=&lt;refractiveindex.refractiveindex.RefractiveIndexMaterial</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_methods.RetrievePulsesFROG" title="core.base_classes_methods.RetrievePulsesFROG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RetrievePulsesFROG</span></code></a></p>
<p>The reconstruction class for VAMPIRE.</p>
<p>[1] B. Seifert and H. Stolz, Meas. Sci. Technol. 20 (2009) 015303 (7pp), 10.1088/0957-0233/20/1/015303 (2008)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE.tau_interferometer">
<span class="sig-name descname"><span class="pre">tau_interferometer</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE.tau_interferometer" title="Link to this definition"></a></dt>
<dd><p>delay of the interferometer arms</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE.c0">
<span class="sig-name descname"><span class="pre">c0</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE.c0" title="Link to this definition"></a></dt>
<dd><p>the speed of light</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE.refractive_index">
<span class="sig-name descname"><span class="pre">refractive_index</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE.refractive_index" title="Link to this definition"></a></dt>
<dd><p>returns the refractive index for a material given a wavelength in um</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>refractiveindex.RefractiveIndexMaterial, Callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE.phase_matrix">
<span class="sig-name descname"><span class="pre">phase_matrix</span></span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE.phase_matrix" title="Link to this definition"></a></dt>
<dd><p>a 2D-array with phase values that could potentially have been applied to a pulse</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE.get_phase_matrix">
<span class="sig-name descname"><span class="pre">get_phase_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refractive_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">material_thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE.get_phase_matrix" title="Link to this definition"></a></dt>
<dd><p>Calculates the phase matrix that is applied of a pulse passes through a material.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE.apply_phase">
<span class="sig-name descname"><span class="pre">apply_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE.apply_phase" title="Link to this definition"></a></dt>
<dd><p>For an VAMPIRE reconstruction one may need to consider effects of material dispersion in the interferometer.
This applies a dispersion based on phase_matrix in order to achieve this.
In addition the dispersion may contain a group delay. This delay is estimated, corrected and returned as well.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classes_methods.RetrievePulsesVAMPIRE.calculate_signal_t">
<span class="sig-name descname"><span class="pre">calculate_signal_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classes_methods.RetrievePulsesVAMPIRE.calculate_signal_t" title="Link to this definition"></a></dt>
<dd><p>Calculates the signal field in the time domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>individual</strong> – Pytree, a population containing only one member. (jax.vmap over whole population)</p></li>
<li><p><strong>tau_arr</strong> (<em>jnp.array</em>) – the delays</p></li>
<li><p><strong>measurement_info</strong> – Pytree, contains the measurement parameters (e.g. nonlinear method, … )</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, contains the signal field in the time domain as well as the fields used to calculate it.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-core.base_classic_algorithms">
<span id="core-base-classic-algorithms-module"></span><h2>core.base_classic_algorithms module<a class="headerlink" href="#module-core.base_classic_algorithms" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.base_classic_algorithms.initialize_CG_state">
<span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">initialize_CG_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.initialize_CG_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.base_classic_algorithms.initialize_pseudo_newton_state">
<span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">initialize_pseudo_newton_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.initialize_pseudo_newton_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.base_classic_algorithms.initialize_lbfgs_state">
<span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">initialize_lbfgs_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.initialize_lbfgs_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.base_classic_algorithms.update_lbfgs_state">
<span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">update_lbfgs_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbfgs_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.update_lbfgs_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.base_classic_algorithms.initialize_linesearch_info">
<span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">initialize_linesearch_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.initialize_linesearch_info" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.base_classic_algorithms.initialize_S_prime_params">
<span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">initialize_S_prime_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.initialize_S_prime_params" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.base_classic_algorithms.initialize_newton_info">
<span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">initialize_newton_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.initialize_newton_info" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">GeneralizedProjectionBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE" title="core.base_classes_algorithms.ClassicAlgorithmsBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicAlgorithmsBASE</span></code></a></p>
<p>Implements the Generalized Projection Algorithm.</p>
<p>[1] K. W. DeLong et al., Opt. Lett. 19, 2152-2154 (1994)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.no_steps_descent">
<span class="sig-name descname"><span class="pre">no_steps_descent</span></span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.no_steps_descent" title="Link to this definition"></a></dt>
<dd><p>the numer of descent steps per iteration</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.update_population">
<span class="sig-name descname"><span class="pre">update_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.update_population" title="Link to this definition"></a></dt>
<dd><p>Applies the descent based update to the population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.get_Z_gradient">
<span class="sig-name descname"><span class="pre">get_Z_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.get_Z_gradient" title="Link to this definition"></a></dt>
<dd><p>Calculates the Z-error gradient for the entire population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.calc_Z_error_for_linesearch">
<span class="sig-name descname"><span class="pre">calc_Z_error_for_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.calc_Z_error_for_linesearch" title="Link to this definition"></a></dt>
<dd><p>Calculates the Z-error such that it can be called in a linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.calc_Z_grad_for_linesearch">
<span class="sig-name descname"><span class="pre">calc_Z_grad_for_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.calc_Z_grad_for_linesearch" title="Link to this definition"></a></dt>
<dd><p>Calculates the Z-error gradient such that it can be called in a linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.descent_Z_error_step">
<span class="sig-name descname"><span class="pre">descent_Z_error_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z_error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.descent_Z_error_step" title="Link to this definition"></a></dt>
<dd><p>Performs a descent step in order to minimize the Z-error.
Employs gradient descent, nonlinear conjugate gradients, LBFGS or damped Newtons method (diagonal or full).
The step size is determined via a fixed/adaptive step size, a backtracking or a zoom linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.do_descent_Z_error_step">
<span class="sig-name descname"><span class="pre">do_descent_Z_error_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.do_descent_Z_error_step" title="Link to this definition"></a></dt>
<dd><p>Does one Z-error descent step. Calls descent_Z_error_step for pulse and or gate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.do_descent_Z_error">
<span class="sig-name descname"><span class="pre">do_descent_Z_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.do_descent_Z_error" title="Link to this definition"></a></dt>
<dd><p>Performs a descent based optimization to find the pulse/gate that are able to produce S_prime.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.step" title="Link to this definition"></a></dt>
<dd><p>Performs one iteration of the Generalized Projection Algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state and the current trace errors of the population.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.GeneralizedProjectionBASE.initialize_run">
<span class="sig-name descname"><span class="pre">initialize_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.GeneralizedProjectionBASE.initialize_run" title="Link to this definition"></a></dt>
<dd><p>Prepares all provided data and parameters for the reconstruction.
Here the final shape/structure of descent_state, measurement_info and descent_info are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>population</strong> – Pytree, the initial guess as created by self.create_initial_population()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, Callable], the initial descent state and the step-function of the algorithm.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">PtychographicIterativeEngineBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE" title="core.base_classes_algorithms.ClassicAlgorithmsBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicAlgorithmsBASE</span></code></a></p>
<p>Implements a version of the Ptychographic Iterative Engine (PIE).</p>
<p>[1] A. Maiden et al., Optica 4, 736-745 (2017)
[2] T. Schweizer, “Time-Domain Ptychography and its Applications in Ultrafast Science”, PhD Thesis, Bern (2021)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.alpha" title="Link to this definition"></a></dt>
<dd><p>a regularization parameter</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.calculate_PIE_error">
<span class="sig-name descname"><span class="pre">calculate_PIE_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.calculate_PIE_error" title="Link to this definition"></a></dt>
<dd><p>Calculates the normalized least-squares error using the amplitude residuals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.get_PIE_weights">
<span class="sig-name descname"><span class="pre">get_PIE_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probe</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pie_method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.get_PIE_weights" title="Link to this definition"></a></dt>
<dd><p>Calculates the weight-functions for the differen PIE-version.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.update_population">
<span class="sig-name descname"><span class="pre">update_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.update_population" title="Link to this definition"></a></dt>
<dd><p>Applies the PIE update to the population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.calculate_PIE_descent_direction">
<span class="sig-name descname"><span class="pre">calculate_PIE_descent_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pie_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.calculate_PIE_descent_direction" title="Link to this definition"></a></dt>
<dd><p>Calculates the descent direction based on the PIE version.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.calc_error_for_linesearch">
<span class="sig-name descname"><span class="pre">calc_error_for_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.calc_error_for_linesearch" title="Link to this definition"></a></dt>
<dd><p>Calculates the PIE-error such that it can be called in a linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.calc_grad_for_linesearch">
<span class="sig-name descname"><span class="pre">calc_grad_for_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.calc_grad_for_linesearch" title="Link to this definition"></a></dt>
<dd><p>Calculates the PIE direction such that it can be called in a linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.do_iteration">
<span class="sig-name descname"><span class="pre">do_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pie_error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.do_iteration" title="Link to this definition"></a></dt>
<dd><p>Performs one local/global iteration of the PIE.
On top of the different PIE-version nonlinear conjugate gradients, LBFGS or damped Newtons method (diagonal or full) may be used.
The step size is determined via a fixed/adaptive step size, a backtracking or a zoom linesearch.</p>
<p>Newtons method with a full newton is not available for the reconstruction of the gate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.local_iteration">
<span class="sig-name descname"><span class="pre">local_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_arr_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace_line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.local_iteration" title="Link to this definition"></a></dt>
<dd><p>Peforms one local iteration. Calls do_iteration() with the appropriate (randomized) signal fields.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.local_step">
<span class="sig-name descname"><span class="pre">local_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.local_step" title="Link to this definition"></a></dt>
<dd><p>Performs one local iteration of the PIE.
This means the method loops over the randomized measurement data once and updates the population using each data point individually.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state and the current trace errors of the population.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.global_step">
<span class="sig-name descname"><span class="pre">global_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.global_step" title="Link to this definition"></a></dt>
<dd><p>Performs one global iteration of the PIE.
This means the method updates the population once using all measured data at once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state and the current trace errors of the population.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.initialize_run">
<span class="sig-name descname"><span class="pre">initialize_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.initialize_run" title="Link to this definition"></a></dt>
<dd><p>Prepares all provided data and parameters for the reconstruction.
Here the final shape/structure of descent_state, measurement_info and descent_info are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>population</strong> – Pytree, the initial guess as created by self.create_initial_population()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, Callable, Callable], the initial descent state, the local and global step-functions of the algorithm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.PtychographicIterativeEngineBASE.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_iterations_local</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_iterations_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.PtychographicIterativeEngineBASE.run" title="Link to this definition"></a></dt>
<dd><p>The Algorithm can use a local and a global sequentially.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population</strong> – Pytree, the initial guess</p></li>
<li><p><strong>no_iterations_local</strong> – int, the number of local iterations. Accepts zero as a value.</p></li>
<li><p><strong>no_iterations_global</strong> – int, the number of globale iterations. Accepts zero as a value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, the final result</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_classic_algorithms.</span></span><span class="sig-name descname"><span class="pre">COPRABASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.ClassicAlgorithmsBASE" title="core.base_classes_algorithms.ClassicAlgorithmsBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicAlgorithmsBASE</span></code></a></p>
<p>Implements a version of the Common Pulse Retrieval Algorithm (COPRA).</p>
<p>[1] N. C. Geib, Optica 6, 495-505 (2019)</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.update_population">
<span class="sig-name descname"><span class="pre">update_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.update_population" title="Link to this definition"></a></dt>
<dd><p>Applies the a descent based update to the population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.get_Z_gradient">
<span class="sig-name descname"><span class="pre">get_Z_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.get_Z_gradient" title="Link to this definition"></a></dt>
<dd><p>Calculates the Z-error gradient for the current population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.calc_Z_error_for_linesearch">
<span class="sig-name descname"><span class="pre">calc_Z_error_for_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.calc_Z_error_for_linesearch" title="Link to this definition"></a></dt>
<dd><p>Calculates the Z-error such that it can be called in a linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.calc_Z_grad_for_linesearch">
<span class="sig-name descname"><span class="pre">calc_Z_grad_for_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.calc_Z_grad_for_linesearch" title="Link to this definition"></a></dt>
<dd><p>Calculates the Z-error gradient such that it can be called in a linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.do_iteration">
<span class="sig-name descname"><span class="pre">do_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_t_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.do_iteration" title="Link to this definition"></a></dt>
<dd><p>Performs one local/global iteration of the Common Pulse Retrieval Algorithm.
Uses gradient descent, nonlinear conjugate gradients, LBFGS or damped Newtons method (diagonal or full).
The step size is determined via a fixed/adaptive step size, a backtracking or a zoom linesearch.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.local_iteration">
<span class="sig-name descname"><span class="pre">local_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_arr_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace_line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.local_iteration" title="Link to this definition"></a></dt>
<dd><p>Peforms one local iteration. Calls do_iteration() with the appropriate (randomized) signal fields.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.local_step">
<span class="sig-name descname"><span class="pre">local_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.local_step" title="Link to this definition"></a></dt>
<dd><p>Performs one local iteration of the Common Pulse Retrieval Algorithm.
This means the method loops over the randomized measurement data once and updates the population using each data point individually.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state and the current trace errors of the population.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.global_step">
<span class="sig-name descname"><span class="pre">global_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.global_step" title="Link to this definition"></a></dt>
<dd><p>Performs one global iteration of the Common Pulse Retrieval Algorithm.
This means the method updates the population once using all measured data at once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state and the current trace errors of the population.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.initialize_run">
<span class="sig-name descname"><span class="pre">initialize_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.initialize_run" title="Link to this definition"></a></dt>
<dd><p>Prepares all provided data and parameters for the reconstruction.
Here the final shape/structure of descent_state, measurement_info and descent_info are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>population</strong> – Pytree, the initial guess as created by create_initial_population()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, Callable, Callable], the initial descent state, the local and global step-functions of the algorithm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_classic_algorithms.COPRABASE.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_iterations_local</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_iterations_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_classic_algorithms.COPRABASE.run" title="Link to this definition"></a></dt>
<dd><p>The Algorithm can use a local and a global sequentially.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>population</strong> – Pytree, the initial guess</p></li>
<li><p><strong>no_iterations_local</strong> – int, the number of local iterations. Accepts zero as a value.</p></li>
<li><p><strong>no_iterations_global</strong> – int, the number of globale iterations. Accepts zero as a value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pytree, the final result</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-core.base_general_optimization">
<span id="core-base-general-optimization-module"></span><h2>core.base_general_optimization module<a class="headerlink" href="#module-core.base_general_optimization" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.base_general_optimization.make_key_tree">
<span class="sig-prename descclassname"><span class="pre">core.base_general_optimization.</span></span><span class="sig-name descname"><span class="pre">make_key_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pytree</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.make_key_tree" title="Link to this definition"></a></dt>
<dd><p>For a given pytree, each leaf is replaced by a prng-key.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.base_general_optimization.shuffle_pytree">
<span class="sig-prename descclassname"><span class="pre">core.base_general_optimization.</span></span><span class="sig-name descname"><span class="pre">shuffle_pytree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pytree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.shuffle_pytree" title="Link to this definition"></a></dt>
<dd><p>Randomizes the leafs of a given pytree along a given axis.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_general_optimization.</span></span><span class="sig-name descname"><span class="pre">DifferentialEvolutionBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.GeneralOptimizationBASE" title="core.base_classes_algorithms.GeneralOptimizationBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralOptimizationBASE</span></code></a></p>
<p>Implements a Differential-Evolution Algorithm.
Based on Qiang, J., Mitchell, C., A Unified Differential Evolution Algorithm for Global Optimization, 2014, <a class="reference external" href="https://www.osti.gov/servlets/purl/1163659">https://www.osti.gov/servlets/purl/1163659</a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.strategy">
<span class="sig-name descname"><span class="pre">strategy</span></span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.strategy" title="Link to this definition"></a></dt>
<dd><p>the mutation and selection strategy, analogous to scipy’s differential evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.mutation_rate">
<span class="sig-name descname"><span class="pre">mutation_rate</span></span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.mutation_rate" title="Link to this definition"></a></dt>
<dd><p>the mutation rate</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.crossover_rate">
<span class="sig-name descname"><span class="pre">crossover_rate</span></span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.crossover_rate" title="Link to this definition"></a></dt>
<dd><p>the crossover rate</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.selection_mechanism">
<span class="sig-name descname"><span class="pre">selection_mechanism</span></span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.selection_mechanism" title="Link to this definition"></a></dt>
<dd><p>the selection mechanism, can be greedy or global, defined in select_population().</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.temperature">
<span class="sig-name descname"><span class="pre">temperature</span></span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.temperature" title="Link to this definition"></a></dt>
<dd><p>a temperature value for the global selection mechanism</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.best1">
<span class="sig-name descname"><span class="pre">best1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.best1" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.best2">
<span class="sig-name descname"><span class="pre">best2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.best2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.rand1">
<span class="sig-name descname"><span class="pre">rand1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.rand1" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.rand2">
<span class="sig-name descname"><span class="pre">rand2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.rand2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.randtobest1">
<span class="sig-name descname"><span class="pre">randtobest1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.randtobest1" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.randtobest2">
<span class="sig-name descname"><span class="pre">randtobest2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.randtobest2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.currenttorand1">
<span class="sig-name descname"><span class="pre">currenttorand1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.currenttorand1" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.currenttorand2">
<span class="sig-name descname"><span class="pre">currenttorand2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.currenttorand2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.currenttobest1">
<span class="sig-name descname"><span class="pre">currenttobest1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.currenttobest1" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.currenttobest2">
<span class="sig-name descname"><span class="pre">currenttobest2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.currenttobest2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.make_bin_mask_tree">
<span class="sig-name descname"><span class="pre">make_bin_mask_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pytree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.make_bin_mask_tree" title="Link to this definition"></a></dt>
<dd><p>For a given pytree a random binary mask is generated on each leaf, via the probabilty p.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.make_exp_mask_tree">
<span class="sig-name descname"><span class="pre">make_exp_mask_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pytree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.make_exp_mask_tree" title="Link to this definition"></a></dt>
<dd><p>For a given pytree a mask (e.g. of the form 111100000) is generated via the probability p on each row of each leaf.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.bin_crossover">
<span class="sig-name descname"><span class="pre">bin_crossover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutant_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.bin_crossover" title="Link to this definition"></a></dt>
<dd><p>Peforms a binary crossover between two populations via the crossover rate CR.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.exp_crossover">
<span class="sig-name descname"><span class="pre">exp_crossover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutant_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.exp_crossover" title="Link to this definition"></a></dt>
<dd><p>Peforms an exponential crossover between two populations via the crossover rate CR.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.smooth_crossover">
<span class="sig-name descname"><span class="pre">smooth_crossover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutant_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.smooth_crossover" title="Link to this definition"></a></dt>
<dd><p>Similar to an exponential crossover but with a smooth nonbinary transition, which is fascilitated via a tanh function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.custom_mutation">
<span class="sig-name descname"><span class="pre">custom_mutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.custom_mutation" title="Link to this definition"></a></dt>
<dd><p>A placeholder to allow the introduction of custom mutation approaches.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.custom_crossover">
<span class="sig-name descname"><span class="pre">custom_crossover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutant_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.custom_crossover" title="Link to this definition"></a></dt>
<dd><p>A placeholder to allow the introduction of custom crossover approaches.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.do_mutation">
<span class="sig-name descname"><span class="pre">do_mutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mutation_strategy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.do_mutation" title="Link to this definition"></a></dt>
<dd><p>Creates and applies random mutations to a population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.do_crossover">
<span class="sig-name descname"><span class="pre">do_crossover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">crossover_strategy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutant_population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.do_crossover" title="Link to this definition"></a></dt>
<dd><p>Creates and applies random crossover events between two populations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.select_population">
<span class="sig-name descname"><span class="pre">select_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selection_mechanism</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_parent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_trial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population_parent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population_trial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.select_population" title="Link to this definition"></a></dt>
<dd><p>Performs the evolutionary selection process for two populations. Currently selection_mechanism can be greedy or global.</p>
<p>greedy: implements a pairwise comparison between individuals of the two population, where always the individual with the higher fitness is selected.
global: implements a comparison/ranking between all individuals of both populations. The next generation is selected via randomized sampling based on a Fermi-Distribution. A “temperature” allows tuning of this selection process.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.step" title="Link to this definition"></a></dt>
<dd><p>Performs one step/generation of the Differential Evolution Algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state, the mean, minimum and maximum error of the current population</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.DifferentialEvolutionBASE.initialize_run">
<span class="sig-name descname"><span class="pre">initialize_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.DifferentialEvolutionBASE.initialize_run" title="Link to this definition"></a></dt>
<dd><p>Prepares all provided data and parameters for the reconstruction.
Here the final shape/structure of descent_state, measurement_info and descent_info are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>population</strong> – Pytree, the initial guess as created by self.create_initial_population()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, Callable], the initial descent state, the step-function of the algorithm.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_general_optimization.EvosaxBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_general_optimization.</span></span><span class="sig-name descname"><span class="pre">EvosaxBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.EvosaxBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.GeneralOptimizationBASE" title="core.base_classes_algorithms.GeneralOptimizationBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralOptimizationBASE</span></code></a></p>
<p>Employs the evosax package to perform the optimization.</p>
<p>[1] Robert Tjarko Lange, evosax: JAX-based Evolution Strategies, arXiv preprint arXiv:2212.04180 (2022)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.EvosaxBASE.solver">
<span class="sig-name descname"><span class="pre">solver</span></span><a class="headerlink" href="#core.base_general_optimization.EvosaxBASE.solver" title="Link to this definition"></a></dt>
<dd><p>any evosax-solver should work</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>evosax-solver</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.EvosaxBASE.step_amp_or_phase">
<span class="sig-name descname"><span class="pre">step_amp_or_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population_amp_or_phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_or_phase</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.EvosaxBASE.step_amp_or_phase" title="Link to this definition"></a></dt>
<dd><p>Evosax does not respect the structure of a pytree. Thus when optimizing parameters with vastly different properties simultaneously
one should expose them seperately to evosax in order to avoid mixing. Thus the step function is applied once to update the amplitudes
and once to update the phases.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.EvosaxBASE.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.EvosaxBASE.step" title="Link to this definition"></a></dt>
<dd><p>Performs one optimization step through an evolutionary algorithm in evosax.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state, the mean, minimum and maximum error of the current population</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.EvosaxBASE.initialize_evosax_solver">
<span class="sig-name descname"><span class="pre">initialize_evosax_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_or_phase</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.EvosaxBASE.initialize_evosax_solver" title="Link to this definition"></a></dt>
<dd><p>Initializes the provided evosax solver.
The solvers need to be exposed to the entire population, one individual or the initial fitnesses.
Since the amplitude and phase are optimized separetly a solver needs to be initialized once for each. (This done by calling this method twice.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.EvosaxBASE.initialize_run">
<span class="sig-name descname"><span class="pre">initialize_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.EvosaxBASE.initialize_run" title="Link to this definition"></a></dt>
<dd><p>Prepares all provided data and parameters for the reconstruction. Initializes the evosax-solver appropriately.
Here the final shape/structure of descent_state, measurement_info and descent_info are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>population</strong> – Pytree, the initial guess as created by self.create_initial_population()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, Callable], the initial descent state, the step-function of the algorithm.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_general_optimization.</span></span><span class="sig-name descname"><span class="pre">LSFBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.GeneralOptimizationBASE" title="core.base_classes_algorithms.GeneralOptimizationBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralOptimizationBASE</span></code></a></p>
<p>Implements a version of the Linesearch FROG Algorithm (LSF). Despite its name the algorithm is NOT restricted to FROG.</p>
<p>The algorithm is not implemented for the optimization of parametrized populations. Instead a population is always evaluated on the time/frequency axis
and thus optimized in its discretized form.</p>
<p>[1] C. O. Krook and V. Pasiskevicius, Opt. Express 33, 33258-33269 (2025)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.number_of_bisection_iterations">
<span class="sig-name descname"><span class="pre">number_of_bisection_iterations</span></span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.number_of_bisection_iterations" title="Link to this definition"></a></dt>
<dd><p>as the name says</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.random_direction_mode">
<span class="sig-name descname"><span class="pre">random_direction_mode</span></span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.random_direction_mode" title="Link to this definition"></a></dt>
<dd><p>can be random or continuous</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.no_points_for_continuous">
<span class="sig-name descname"><span class="pre">no_points_for_continuous</span></span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.no_points_for_continuous" title="Link to this definition"></a></dt>
<dd><p>smaller value means less continuous</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.get_random_values">
<span class="sig-name descname"><span class="pre">get_random_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.get_random_values" title="Link to this definition"></a></dt>
<dd><p>LSF requires random directions. These are produced here.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.get_search_direction_individual">
<span class="sig-name descname"><span class="pre">get_search_direction_individual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.get_search_direction_individual" title="Link to this definition"></a></dt>
<dd><p>Creates a pytree with random search directions for one individual.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.get_search_direction">
<span class="sig-name descname"><span class="pre">get_search_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.get_search_direction" title="Link to this definition"></a></dt>
<dd><p>Creates a pytree with random search directions for an entire population.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.get_scalars">
<span class="sig-name descname"><span class="pre">get_scalars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.get_scalars" title="Link to this definition"></a></dt>
<dd><p>Calculates scalars to identify the min/max of a search direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.bisection_step_logic_0">
<span class="sig-name descname"><span class="pre">bisection_step_logic_0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">El</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Em</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Er</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.bisection_step_logic_0" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.bisection_step_logic_1">
<span class="sig-name descname"><span class="pre">bisection_step_logic_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">El</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Em</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Er</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.bisection_step_logic_1" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.bisection_step_logic_2">
<span class="sig-name descname"><span class="pre">bisection_step_logic_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">El</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Em</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Er</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.bisection_step_logic_2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.bisection_step">
<span class="sig-name descname"><span class="pre">bisection_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">El</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Er</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.bisection_step" title="Link to this definition"></a></dt>
<dd><p>Does one bisection step of the LSF algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.do_bisection_search">
<span class="sig-name descname"><span class="pre">do_bisection_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.do_bisection_search" title="Link to this definition"></a></dt>
<dd><p>Performs one bisection search to find the minimum along a given search direction.
The number of iterations is set through self.number_of_bisection_iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.search_along_direction">
<span class="sig-name descname"><span class="pre">search_along_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.search_along_direction" title="Link to this definition"></a></dt>
<dd><p>Performs a bisection search along one direction for pulse and the for gate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.make_population_bisection_search">
<span class="sig-name descname"><span class="pre">make_population_bisection_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.make_population_bisection_search" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.calculate_error">
<span class="sig-name descname"><span class="pre">calculate_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.calculate_error" title="Link to this definition"></a></dt>
<dd><p>Calculates the trace error. Since pulse and gate are optimized independently the population as provided to calculate_error_individual()
needs to be constructed from the current population and the fields in the cureent optimization.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.step" title="Link to this definition"></a></dt>
<dd><p>Performs one step of the LSF-algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state, errors of the current population</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.initialize_run">
<span class="sig-name descname"><span class="pre">initialize_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.initialize_run" title="Link to this definition"></a></dt>
<dd><p>Prepares all provided data and parameters for the reconstruction.
Here the final shape/structure of descent_state, measurement_info and descent_info are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>population</strong> – Pytree, the initial guess as created by self.create_initial_population()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, Callable], the initial descent state, the step-function of the algorithm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.LSFBASE.post_process_get_pulse_and_gate">
<span class="sig-name descname"><span class="pre">post_process_get_pulse_and_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.LSFBASE.post_process_get_pulse_and_gate" title="Link to this definition"></a></dt>
<dd><p>Some custom post-processing since the optimization is done in the explicit discretized form.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.base_general_optimization.</span></span><span class="sig-name descname"><span class="pre">AutoDiffBASE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#core.base_classes_algorithms.GeneralOptimizationBASE" title="core.base_classes_algorithms.GeneralOptimizationBASE"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralOptimizationBASE</span></code></a></p>
<p>Employs the optimistix package to perform the optimization via Automatic-Differentiation.</p>
<p>[1] J. Rader, T. Lyons and P.Kidger, Optimistix: modular optimisation in JAX and Equinox, arXiv:2402.09983 (2024)
[2] DeepMind et al., The DeepMind JAX Ecosystem, http://github.com/google-deepmind (2020)</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.solver">
<span class="sig-name descname"><span class="pre">solver</span></span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.solver" title="Link to this definition"></a></dt>
<dd><p>optax-solvers need to be initialized</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>optimistix-solver, optax-solver</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.alternating_optimization">
<span class="sig-name descname"><span class="pre">alternating_optimization</span></span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.alternating_optimization" title="Link to this definition"></a></dt>
<dd><p>if true, the optimizer alternates between amplitude and phase</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.get_phase">
<span class="sig-name descname"><span class="pre">get_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">central_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.get_phase" title="Link to this definition"></a></dt>
<dd><p>Wraps around GeneralOptimizationBASE.get_phase() in order to fascilliate the optimization of the group delay.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.loss_function">
<span class="sig-name descname"><span class="pre">loss_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.loss_function" title="Link to this definition"></a></dt>
<dd><p>Wraps around self.calculate_error_individual() to return the error of the current guess.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.loss_function_amp">
<span class="sig-name descname"><span class="pre">loss_function_amp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual_amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">individual_phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.loss_function_amp" title="Link to this definition"></a></dt>
<dd><p>Helper to fascilliate optimization with respect to the amplitude only.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.loss_function_phase">
<span class="sig-name descname"><span class="pre">loss_function_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">individual_phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">individual_amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.loss_function_phase" title="Link to this definition"></a></dt>
<dd><p>Helper to fascilliate optimization with respect to the phase only.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.step" title="Link to this definition"></a></dt>
<dd><p>Performs one optimization step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_state</strong> – Pytree,</p></li>
<li><p><strong>measurement_info</strong> – Pytree,</p></li>
<li><p><strong>descent_info</strong> – Pytree,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, jnp.array], the updated descent state, errors of the current population</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.initialize_alternating_optimization">
<span class="sig-name descname"><span class="pre">initialize_alternating_optimization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimistix_args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.initialize_alternating_optimization" title="Link to this definition"></a></dt>
<dd><p>If the amplitude and phase are supposed to be optimized in an alternating fashion instead of simultaneously, different methods have to be initialized.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.initialize_optimistix">
<span class="sig-name descname"><span class="pre">initialize_optimistix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.initialize_optimistix" title="Link to this definition"></a></dt>
<dd><p>Initializes the optimistix-solver.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.base_general_optimization.AutoDiffBASE.initialize_run">
<span class="sig-name descname"><span class="pre">initialize_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">population</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.base_general_optimization.AutoDiffBASE.initialize_run" title="Link to this definition"></a></dt>
<dd><p>Prepares all provided data and parameters for the reconstruction.
Here the final shape/structure of descent_state, measurement_info and descent_info are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>population</strong> – Pytree, the initial guess as created by self.create_initial_population()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[Pytree, Callable], the initial descent state, the step-function of the algorithm.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-core.bsplines_1d">
<span id="core-bsplines-1d-module"></span><h2>core.bsplines_1d module<a class="headerlink" href="#module-core.bsplines_1d" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.bsplines_1d.get_C_in">
<span class="sig-prename descclassname"><span class="pre">core.bsplines_1d.</span></span><span class="sig-name descname"><span class="pre">get_C_in</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.bsplines_1d.get_C_in" title="Link to this definition"></a></dt>
<dd><p>Naive implementation of n choose i.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.bsplines_1d.get_m_ij">
<span class="sig-prename descclassname"><span class="pre">core.bsplines_1d.</span></span><span class="sig-name descname"><span class="pre">get_m_ij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.bsplines_1d.get_m_ij" title="Link to this definition"></a></dt>
<dd><p>Calculates matrix elements (i,j) for a uniform bspline matrix of order k.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.bsplines_1d.get_M">
<span class="sig-prename descclassname"><span class="pre">core.bsplines_1d.</span></span><span class="sig-name descname"><span class="pre">get_M</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.bsplines_1d.get_M" title="Link to this definition"></a></dt>
<dd><p>Calculates a basis matrix for uniform bsplines of order k.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.bsplines_1d.get_prefactor">
<span class="sig-prename descclassname"><span class="pre">core.bsplines_1d.</span></span><span class="sig-name descname"><span class="pre">get_prefactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.bsplines_1d.get_prefactor" title="Link to this definition"></a></dt>
<dd><p>Calculates the prefactor for a basis matrix for uniform bsplines of order k.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.bsplines_1d.make_bsplines">
<span class="sig-prename descclassname"><span class="pre">core.bsplines_1d.</span></span><span class="sig-name descname"><span class="pre">make_bsplines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.bsplines_1d.make_bsplines" title="Link to this definition"></a></dt>
<dd><p>Evaluate arbitrary order bsplines in 1D.</p>
</dd></dl>

</section>
<section id="module-core.construct_s_prime">
<span id="core-construct-s-prime-module"></span><h2>core.construct_s_prime module<a class="headerlink" href="#module-core.construct_s_prime" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_S_prime_projection">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_S_prime_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_S_prime_projection" title="Link to this definition"></a></dt>
<dd><p>Calculates signal_t_new/S_prime via a projection onto the measured intensity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_f</strong> (<em>jnp.array</em>) – the complex signal field in the frequency domain of the current guess</p></li>
<li><p><strong>measured_trace</strong> (<em>jnp.array</em>) – the measured intensity</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – the scaling factor between the measured intensity and the intensity of the current guess</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – contains measurement data and information</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>jnp.array, the complex signal field in the time domain projected onto the measured intensity</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_newton_diagonal_intensity">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_newton_diagonal_intensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_newton_diagonal_intensity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_newton_diagonal_amplitude">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_newton_diagonal_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_newton_diagonal_amplitude" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_newton_diagonal">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_newton_diagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_newton_diagonal" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_gradient_intensity">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_gradient_intensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_gradient_intensity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_gradient_amplitude">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_gradient_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_gradient_amplitude" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_gradient">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_gradient" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_descent_direction">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_descent_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_descent_direction" title="Link to this definition"></a></dt>
<dd><p>Calculates descent direction of the iterative calculation of signal_t_new/S_prime.
Uses either gradient descent or newtons method with the diagonal approximation.
The error-functions can be based on intensity or amplitude based residuals.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_error_intensity">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_error_intensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_error_intensity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_error_amplitude">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_error_amplitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_error_amplitude" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_r_error">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_r_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_r_error" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_S_prime_iterative_step">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_S_prime_iterative_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_S_prime_iterative_step" title="Link to this definition"></a></dt>
<dd><p>One iteration of the iterative descent based calculation of signal_t_new/S_prime.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_S_prime_iterative">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_S_prime_iterative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_S_prime_iterative" title="Link to this definition"></a></dt>
<dd><p>Calculates signal_t_new/S_prime via an iterative optimization of the least-squares error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_t</strong> (<em>jnp.array</em>) – the complex signal field in the time domain of the current guess</p></li>
<li><p><strong>signal_t</strong> – the complex signal field in the frequency domain of the current guess</p></li>
<li><p><strong>measured_trace</strong> (<em>jnp.array</em>) – the measured intensity</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – the scaling factor between the measured intensity and the intensity of the current guess</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – contains measurement data and information</p></li>
<li><p><strong>descent_info</strong> (<em>Pytree</em>) – contains information on the behaviour of the solver</p></li>
<li><p><strong>local_or_global</strong> (<em>str</em>) – whether this is used in a local or global iteration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>jnp.array, the complex signal field in the time domain projected onto the measured intensity</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.construct_s_prime.calculate_S_prime">
<span class="sig-prename descclassname"><span class="pre">core.construct_s_prime.</span></span><span class="sig-name descname"><span class="pre">calculate_S_prime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.construct_s_prime.calculate_S_prime" title="Link to this definition"></a></dt>
<dd><p>Calculates signal_t_new/S_prime via projection or iterative optimization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_t</strong> (<em>jnp.array</em>) – the complex signal field in the time domain of the current guess</p></li>
<li><p><strong>signal_f</strong> (<em>jnp.array</em>) – the complex signal field in the frequency domain of the current guess</p></li>
<li><p><strong>measured_trace</strong> (<em>jnp.array</em>) – the measured intensity</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – the scaling factor between the measured intensity and the intensity of the current guess</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – contains measurement data and information</p></li>
<li><p><strong>descent_info</strong> (<em>Pytree</em>) – contains information on the behaviour of the solver</p></li>
<li><p><strong>local_or_global</strong> (<em>str</em>) – whether this is used in a local or global iteration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>jnp.array, the complex signal field in the time domain projected onto the measured intensity</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-core.create_population">
<span id="core-create-population-module"></span><h2>core.create_population module<a class="headerlink" href="#module-core.create_population" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.get_initial_amp">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">get_initial_amp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.get_initial_amp" title="Link to this definition"></a></dt>
<dd><p>Estimate spectral amplitude from the integrated measured intensity.
For SHG/THG the amplitude is interpolated to lie in the correct frequency region.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.random">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">random</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.random" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.random_phase">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">random_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.random_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.constant">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.constant" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.constant_phase">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">constant_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.constant_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.create_population_classic">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">create_population_classic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.create_population_classic" title="Link to this definition"></a></dt>
<dd><p>Creates a stack of initial guesses with the shape (population_size, jnp.size(frequency)). The guesses are all in the frequency domain.
The created populations can be optimized by both general and classical solvers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>jnp.array</em>) – jax.random.PRNGKey</p></li>
<li><p><strong>population_size</strong> (<em>int</em>) – the number of guesses to be optimized</p></li>
<li><p><strong>guess_type</strong> (<em>str</em>) – the guess mode. Has to be one of random, random_phase, constant or constant_phase. doublepulse is moved to initial_guess_doublepulse.py</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – holds the measurement information, is filled during initialization of each solver</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>jnp.array, stack of 1D-arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.polynomial_guess">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">polynomial_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.polynomial_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.sinusoidal_guess">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">sinusoidal_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.sinusoidal_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.sigmoidal_guess">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">sigmoidal_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.sigmoidal_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.bspline_guess_phase">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">bspline_guess_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.bspline_guess_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.continuous_discrete_guess_phase">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">continuous_discrete_guess_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.continuous_discrete_guess_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.gaussian_or_lorentzian_guess">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">gaussian_or_lorentzian_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.gaussian_or_lorentzian_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.continuous_discrete_guess_amp">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">continuous_discrete_guess_amp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.continuous_discrete_guess_amp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.bspline_guess_amp">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">bspline_guess_amp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.bspline_guess_amp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.general_phase">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">general_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.general_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.general_amp">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">general_amp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.general_amp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.create_phase">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">create_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.create_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.create_amp">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">create_amp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.create_amp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.create_population.create_population_general">
<span class="sig-prename descclassname"><span class="pre">core.create_population.</span></span><span class="sig-name descname"><span class="pre">create_population_general</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_funcs_amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_funcs_phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum_provided</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.create_population.create_population_general" title="Link to this definition"></a></dt>
<dd><p>Creates an initial guess population for general solvers. Since general solvers do not require a grid, different
representations for amplitude and phase can be used. The population is represented in the freqeuncy domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>jnp.array</em>) – jax.random.PRNGKey</p></li>
<li><p><strong>amp_type</strong> (<em>str</em>) – representation of the amplitude</p></li>
<li><p><strong>phase_type</strong> (<em>str</em>) – representation of the phase</p></li>
<li><p><strong>population</strong> (<em>Pytree</em>) – a MyNamespace object containing amp and phase</p></li>
<li><p><strong>population_size</strong> (<em>int</em>) – the number of individuals to optimize</p></li>
<li><p><strong>no_funcs_amp</strong> (<em>int</em>) – some representations can consist of multiple basis functions</p></li>
<li><p><strong>no_funcs_phase</strong> (<em>int</em>) – some representations can consist of multiple basis functions</p></li>
<li><p><strong>spectrum_provided</strong> (<em>bool</em>) – if a spectrum is provided then the guessed population will not include an amplitude</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – holds the measurement information, is filled during initialization of each solver</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[jnp.array, Pytree]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-core.initial_guess_doublepulse">
<span id="core-initial-guess-doublepulse-module"></span><h2>core.initial_guess_doublepulse module<a class="headerlink" href="#module-core.initial_guess_doublepulse" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.initial_guess_doublepulse.gaussian">
<span class="sig-prename descclassname"><span class="pre">core.initial_guess_doublepulse.</span></span><span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.initial_guess_doublepulse.gaussian" title="Link to this definition"></a></dt>
<dd><p>Gaussian for fit.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.initial_guess_doublepulse.get_double_pulse_amps">
<span class="sig-prename descclassname"><span class="pre">core.initial_guess_doublepulse.</span></span><span class="sig-name descname"><span class="pre">get_double_pulse_amps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.initial_guess_doublepulse.get_double_pulse_amps" title="Link to this definition"></a></dt>
<dd><p>Estimate temporal amplitude based on Trace. Takes average along frequency axis. Fits gaussians and constructs guess from fit result.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.initial_guess_doublepulse.get_flat_spectral_phase">
<span class="sig-prename descclassname"><span class="pre">core.initial_guess_doublepulse.</span></span><span class="sig-name descname"><span class="pre">get_flat_spectral_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monochromatic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.initial_guess_doublepulse.get_flat_spectral_phase" title="Link to this definition"></a></dt>
<dd><p>Construct linear spectral phase in time domain.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.initial_guess_doublepulse.get_double_pulse_initial_guess">
<span class="sig-prename descclassname"><span class="pre">core.initial_guess_doublepulse.</span></span><span class="sig-name descname"><span class="pre">get_double_pulse_initial_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monochromatic_double_pulse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_want_control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.initial_guess_doublepulse.get_double_pulse_initial_guess" title="Link to this definition"></a></dt>
<dd><p>Finds an initial guess for an autocorrelation FROG trace for doublepulses. Works by finding the delays, amplitudes and central frequencies
through scipy’s peak finder and gaussian fits.
Does use or work with jax.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tau_arr</strong> (<em>jnp.array</em>) – the delay axis 1D-array</p></li>
<li><p><strong>frequency</strong> (<em>jnp.array</em>) – the frequency axis 1D-array</p></li>
<li><p><strong>measured_trace</strong> (<em>jnp.array</em>) – the measured trace 2D-array</p></li>
<li><p><strong>nonlinear_method</strong> (<em>str</em>) – the nonlinear method</p></li>
<li><p><strong>monochromatic_double_pulse</strong> (<em>bool</em>) – whether the doublepulses had different central frequencies</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – a smoothing parameter</p></li>
<li><p><strong>init_std</strong> (<em>float</em>) – initial value for width of gaussian fits</p></li>
<li><p><strong>i_want_control</strong> (<em>bool</em>) – this method does not really work and is disabled for SHG/THG, can be overwritten by this</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[jnp.array, jnp.array], guess in time and frequency domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.initial_guess_doublepulse.make_population_doublepulse">
<span class="sig-prename descclassname"><span class="pre">core.initial_guess_doublepulse.</span></span><span class="sig-name descname"><span class="pre">make_population_doublepulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">population_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_trace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monochromatic_double_pulse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_want_control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.initial_guess_doublepulse.make_population_doublepulse" title="Link to this definition"></a></dt>
<dd><p>Create an initial guess population for a doublepulse using get_double_pulse_initial_guess, with its restrictions.
The population is constructed from a deterministic doublepulse guess by adding noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>jnp.array</em>) – a jax.random.PRNGKey</p></li>
<li><p><strong>population_size</strong> (<em>int</em>) – the number of initial guesses</p></li>
<li><p><strong>tau_arr</strong> (<em>jnp.array</em>) – the delay axis 1D-array</p></li>
<li><p><strong>frequency</strong> (<em>jnp.array</em>) – the frequency axis 1D-array</p></li>
<li><p><strong>measured_trace</strong> (<em>jnp.array</em>) – the measured trace 2D-array</p></li>
<li><p><strong>nonlinear_method</strong> (<em>str</em>) – the nonlinear method</p></li>
<li><p><strong>monochromatic_double_pulse</strong> (<em>bool</em>) – whether the doublepulses had different central frequencies</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – a smoothing parameter</p></li>
<li><p><strong>init_std</strong> (<em>float</em>) – initial value for width of gaussian fits</p></li>
<li><p><strong>i_want_control</strong> (<em>bool</em>) – this method does not really work and is disabled for SHG/THG, can be overwritten by this</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>jnp.array</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-core.lbfgs">
<span id="core-lbfgs-module"></span><h2>core.lbfgs module<a class="headerlink" href="#module-core.lbfgs" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.lbfgs.backward_loop">
<span class="sig-prename descclassname"><span class="pre">core.lbfgs.</span></span><span class="sig-name descname"><span class="pre">backward_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.lbfgs.backward_loop" title="Link to this definition"></a></dt>
<dd><p>Constructing the LBFGS direction without materializing the inverse newton is done through nested vector-operations.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.lbfgs.forward_loop">
<span class="sig-prename descclassname"><span class="pre">core.lbfgs.</span></span><span class="sig-name descname"><span class="pre">forward_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.lbfgs.forward_loop" title="Link to this definition"></a></dt>
<dd><p>Constructing the LBFGS direction without materializing the inverse newton is done through nested vector-operations.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.lbfgs.calculate_quasi_newton_direction">
<span class="sig-prename descclassname"><span class="pre">core.lbfgs.</span></span><span class="sig-name descname"><span class="pre">calculate_quasi_newton_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad_current</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newton_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.lbfgs.calculate_quasi_newton_direction" title="Link to this definition"></a></dt>
<dd><p>Does the actual LBFGS calculation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.lbfgs.do_lbfgs">
<span class="sig-prename descclassname"><span class="pre">core.lbfgs.</span></span><span class="sig-name descname"><span class="pre">do_lbfgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad_current</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbfgs_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.lbfgs.do_lbfgs" title="Link to this definition"></a></dt>
<dd><p>Prepares and calls the LBFGS calculation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.lbfgs.get_quasi_newton_direction">
<span class="sig-prename descclassname"><span class="pre">core.lbfgs.</span></span><span class="sig-name descname"><span class="pre">get_quasi_newton_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbfgs_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.lbfgs.get_quasi_newton_direction" title="Link to this definition"></a></dt>
<dd><p>Calculate the quasi-newton direciton using LBFGS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grad</strong> (<em>jnp.array</em>) – the current gradient</p></li>
<li><p><strong>lbfgs_stat</strong> (<em>Pytree</em>) – the current lbfgs state</p></li>
<li><p><strong>descent_info</strong> (<em>Pytree</em>) – holds information on the solver (e.g. memory size for LBFGS)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[jnp.array, Pytree], the quasi-newton direction and the unchanged lbfgs_state</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-core.nonlinear_cg">
<span id="core-nonlinear-cg-module"></span><h2>core.nonlinear_cg module<a class="headerlink" href="#module-core.nonlinear_cg" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.nonlinear_cg.get_nonlinear_CG_direction">
<span class="sig-prename descclassname"><span class="pre">core.nonlinear_cg.</span></span><span class="sig-name descname"><span class="pre">get_nonlinear_CG_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descent_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta_parameter_version</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.nonlinear_cg.get_nonlinear_CG_direction" title="Link to this definition"></a></dt>
<dd><p>Calculates the descent direction using Nonlinear Conjugate Gradients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>descent_direction</strong> (<em>jnp.array</em>) – the descent direction from a descent solver</p></li>
<li><p><strong>cg</strong> (<em>Pytree</em>) – the current conjugate gradient state, holds the previous descent direction etc.</p></li>
<li><p><strong>beta_parameter_version</strong> (<em>str</em>) – the concrete NCG method to use</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[jnp.array, Pytree], the descent direction based on NCG, the updated NCG state</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.nonlinear_cg.get_beta">
<span class="sig-prename descclassname"><span class="pre">core.nonlinear_cg.</span></span><span class="sig-name descname"><span class="pre">get_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta_parameter_version</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.nonlinear_cg.get_beta" title="Link to this definition"></a></dt>
<dd><p>Calls the NCG-parameter functions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.nonlinear_cg.beta_fletcher_reeves">
<span class="sig-prename descclassname"><span class="pre">core.nonlinear_cg.</span></span><span class="sig-name descname"><span class="pre">beta_fletcher_reeves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction_prev</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.nonlinear_cg.beta_fletcher_reeves" title="Link to this definition"></a></dt>
<dd><p>Compute beta based on Fletcher-Reeves.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.nonlinear_cg.beta_polak_ribiere">
<span class="sig-prename descclassname"><span class="pre">core.nonlinear_cg.</span></span><span class="sig-name descname"><span class="pre">beta_polak_ribiere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction_prev</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.nonlinear_cg.beta_polak_ribiere" title="Link to this definition"></a></dt>
<dd><p>Compute beta based one Polak-Ribiere.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.nonlinear_cg.beta_hestenes_stiefel">
<span class="sig-prename descclassname"><span class="pre">core.nonlinear_cg.</span></span><span class="sig-name descname"><span class="pre">beta_hestenes_stiefel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction_prev</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.nonlinear_cg.beta_hestenes_stiefel" title="Link to this definition"></a></dt>
<dd><p>Compute beta based on Hestenes-Stiefel.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.nonlinear_cg.beta_dai_yuan">
<span class="sig-prename descclassname"><span class="pre">core.nonlinear_cg.</span></span><span class="sig-name descname"><span class="pre">beta_dai_yuan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction_prev</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.nonlinear_cg.beta_dai_yuan" title="Link to this definition"></a></dt>
<dd><p>Compute beta based on Dai-Yuan.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.nonlinear_cg.beta_average">
<span class="sig-prename descclassname"><span class="pre">core.nonlinear_cg.</span></span><span class="sig-name descname"><span class="pre">beta_average</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction_prev</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.nonlinear_cg.beta_average" title="Link to this definition"></a></dt>
<dd><p>Compute beta as an average of the existing methods.</p>
</dd></dl>

</section>
<section id="module-core.phase_matrix_funcs">
<span id="core-phase-matrix-funcs-module"></span><h2>core.phase_matrix_funcs module<a class="headerlink" href="#module-core.phase_matrix_funcs" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.get_parameters_material_scan">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">get_parameters_material_scan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shelf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'main'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">book</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SiO2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">page</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Malitson'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.get_parameters_material_scan" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calculate_phase_matrix_material">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calculate_phase_matrix_material</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calculate_phase_matrix_material" title="Link to this definition"></a></dt>
<dd><p>Calculates a phase matrix via material dispersion. Not differentiable due to usage of refractiveindex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – holds measurement data and parameters, needs to contain the material thickness z_arr in mm.</p></li>
<li><p><strong>parameters</strong> (<em>refractiveindex.RefractiveIndexMaterial</em>) – an object providing the refractive index, the speed of light in m/s</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>jnp.array, the calculated phase matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calc_sine_phase">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calc_sine_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calc_sine_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calc_tanh_phase">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calc_tanh_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calc_tanh_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calc_gaussian_phase">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calc_gaussian_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calc_gaussian_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calc_MIIPS_phase">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calc_MIIPS_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calc_MIIPS_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calc_G_MIIPS_phase">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calc_G_MIIPS_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calc_G_MIIPS_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calculate_phase_matrix">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calculate_phase_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_func=&lt;function</span> <span class="pre">calc_MIIPS_phase&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calculate_phase_matrix" title="Link to this definition"></a></dt>
<dd><p>Calculates a phase matrix using a specified phase function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – holds measurement data and parameters, needs to contain the shift-values in appropriate units</p></li>
<li><p><strong>parameters</strong> (<em>tuple</em>) – the parameters which are expected by phase_func</p></li>
<li><p><strong>phase_func</strong> (<em>Callable</em>) – defines how the phase is calculated</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>jnp.array, the calculated phase matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.phase_matrix_funcs.calc_GDD">
<span class="sig-prename descclassname"><span class="pre">core.phase_matrix_funcs.</span></span><span class="sig-name descname"><span class="pre">calc_GDD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_func=&lt;function</span> <span class="pre">calc_sine_phase&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.phase_matrix_funcs.calc_GDD" title="Link to this definition"></a></dt>
<dd><p>Uses jax.grad to get the GDD of phase_func. Thus doesnt work with non-differentiable functions. Assumes phase_func is holomorphic.</p>
</dd></dl>

</section>
<section id="module-core.spectral_filter_funcs">
<span id="core-spectral-filter-funcs-module"></span><h2>core.spectral_filter_funcs module<a class="headerlink" href="#module-core.spectral_filter_funcs" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.spectral_filter_funcs.gaussian_filter">
<span class="sig-prename descclassname"><span class="pre">core.spectral_filter_funcs.</span></span><span class="sig-name descname"><span class="pre">gaussian_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.spectral_filter_funcs.gaussian_filter" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.spectral_filter_funcs.lorentzian_filter">
<span class="sig-prename descclassname"><span class="pre">core.spectral_filter_funcs.</span></span><span class="sig-name descname"><span class="pre">lorentzian_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.spectral_filter_funcs.lorentzian_filter" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.spectral_filter_funcs.rectangular_filter">
<span class="sig-prename descclassname"><span class="pre">core.spectral_filter_funcs.</span></span><span class="sig-name descname"><span class="pre">rectangular_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.spectral_filter_funcs.rectangular_filter" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.spectral_filter_funcs.multi_filter">
<span class="sig-prename descclassname"><span class="pre">core.spectral_filter_funcs.</span></span><span class="sig-name descname"><span class="pre">multi_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.spectral_filter_funcs.multi_filter" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.spectral_filter_funcs.get_filter">
<span class="sig-prename descclassname"><span class="pre">core.spectral_filter_funcs.</span></span><span class="sig-name descname"><span class="pre">get_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.spectral_filter_funcs.get_filter" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-core.stepsize">
<span id="core-stepsize-module"></span><h2>core.stepsize module<a class="headerlink" href="#module-core.stepsize" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.backtracking_linesearch">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">backtracking_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linesearch_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.backtracking_linesearch" title="Link to this definition"></a></dt>
<dd><p>Perform one iteration of an Armijo-style linesearch.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linesearch_state</strong> (<em>Pytree</em>) – contains the armijo condition, gamma and iteration</p></li>
<li><p><strong>error_func</strong> (<em>Callable</em>) – calculates the error to be optimized, expects gamma, linesearch_info and measurement_info</p></li>
<li><p><strong>grad_func</strong> (<em>Callable</em>) – unused</p></li>
<li><p><strong>linesearch_params</strong> (<em>Pytree</em>) – contains parameters for the linesearch iteration</p></li>
<li><p><strong>linesearch_info</strong> (<em>Pytree</em>) – contains variables related to the initial state of the linesearch</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – contains measurement data and parameters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>MyNamespace, the updated linesearch_state</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.zoom_interpolation">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">zoom_interpolation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.zoom_interpolation" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.finding_phase">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">finding_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bracket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.finding_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.zoom_phase">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">zoom_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bracket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.zoom_phase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.zoom_linesearch">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">zoom_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linesearch_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.zoom_linesearch" title="Link to this definition"></a></dt>
<dd><p>Perform one iteration of an zoom linesearch. Works in two phases. In the first phase an interval containing a minimum is
located by doubling of the step size and observation of the behavior of the error and error-gradient.
If a suitable interval has been located the minimum is approximated/found through successive cubic interpolation.
The search terminates if the Armijo- and Wolfe conditions are met.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linesearch_state</strong> (<em>Pytree</em>) – contains information on the current state of the linesearch</p></li>
<li><p><strong>error_func</strong> (<em>Callable</em>) – calculates the error to be optimized, expects gamma, linesearch_info and measurement_info</p></li>
<li><p><strong>grad_func</strong> (<em>Callable</em>) – calculates the error-gradient to be optimized, expects gamma, linesearch_info and measurement_info</p></li>
<li><p><strong>linesearch_params</strong> (<em>Pytree</em>) – contains parameters for the linesearch iteration</p></li>
<li><p><strong>linesearch_info</strong> (<em>Pytree</em>) – contains variables related to the initial state of the linesearch</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – contains measurement data and parameters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>MyNamespace, the updated linesearch_state</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.do_linesearch_step">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">do_linesearch_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linesearch_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.do_linesearch_step" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.end_linesearch">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">end_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linesearch_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_steps_linesearch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.end_linesearch" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.do_linesearch">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">do_linesearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linesearch_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.do_linesearch" title="Link to this definition"></a></dt>
<dd><p>Perform a linesearch to obtain an improved step size in a descent based optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linesearch_info</strong> (<em>Pytree</em>) – holds information on the initial state at gamma=0</p></li>
<li><p><strong>measurement_info</strong> (<em>Pytree</em>) – holds measurement data and parameters</p></li>
<li><p><strong>descent_info</strong> (<em>Pytree</em>) – holds parameters of the descent algorithm</p></li>
<li><p><strong>error_func</strong> (<em>Callable</em>) – calculates the error to be optimized, expects gamma, linesearch_info, measurement_info</p></li>
<li><p><strong>grad_func</strong> (<em>Callable</em>) – calculates the gradient of error_func, expects gamma, linesearch_info, measurement_info</p></li>
<li><p><strong>local_or_global</strong> (<em>str</em>) – whether this is used in a local or global iteration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float, the approximated optimal step size</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.get_scaling">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">get_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.get_scaling" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="core.stepsize.adaptive_step_size">
<span class="sig-prename descclassname"><span class="pre">core.stepsize.</span></span><span class="sig-name descname"><span class="pre">adaptive_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descent_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_or_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_or_global</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.stepsize.adaptive_step_size" title="Link to this definition"></a></dt>
<dd><p>Calculate an improved step size based through a pade approximation of the error function at the current position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>error</strong> (<em>float</em>) – the current error</p></li>
<li><p><strong>gradient</strong> (<em>jnp.array</em>) – the current gradient</p></li>
<li><p><strong>descent_direction</strong> (<em>jnp.array</em>) – the current descent direction</p></li>
<li><p><strong>local_or_global_state</strong> (<em>Pytree</em>) – holds information of the current descent_state</p></li>
<li><p><strong>xi</strong> (<em>float</em>) – a damping factor to avoid division by zero</p></li>
<li><p><strong>order</strong> (<em>str</em>) – the pade-approximation to be used, can be one of pade_10 (linear), pade_20 (nonlinear), pade_01, pade_11 or pade_02</p></li>
<li><p><strong>pulse_or_gate</strong> (<em>str</em>) – whether this is applied to pulse or gate</p></li>
<li><p><strong>local_or_global</strong> (<em>str</em>) – whether this happens inside a local or global iteration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[jnp.array, Pytree], the scaled descent direction and the local_or_global_state</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-core">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-core" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="real_fields.html" class="btn btn-neutral float-left" title="real_fields package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="core.gradients.html" class="btn btn-neutral float-right" title="core.gradients package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Till Stehling.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>